
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module Actividad2(

	//////////// SEG7 //////////
	output		     [6:0]		HEX0,
	output		     [6:0]		HEX1,
	output		     [6:0]		HEX2,
	output		     [6:0]		HEX3,
	output		     [6:0]		HEX4,
	output		     [6:0]		HEX5,

	//////////// KEY //////////
	input 		     [3:0]		KEY,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// SW //////////
	input 		     [9:0]		SW
);



//=======================================================
//  REG/WIRE declarations
//=======================================================

wire [7:0] inRegister [7:0]; //8 entradas a registros
wire [7:0] outRegister [7:0]; //8 salidas de registros
wire clk [7:0]; //8 clocks de entrada a registros
wire [7:0] S [7:0]; 
wire [2:0] Cin; //Contador ascendente de 3 bits para el select de los DEMUX
wire [2:0] Cout; //Contador ascendente de 3 bits para el select del MUX
wire [7:0] resMS;
wire [9:0] res;
wire [3:0] unit;
wire [3:0] tens;
wire [3:0] hunds;
wire [6:0] seg1;
wire [6:0] seg2;
wire [6:0] seg3;

//=======================================================
//  Structural coding
//=======================================================

register r0(
.clk(clk[0]),
.in(inRegister[0]),
.out(outRegister[0])
);

register r1(
.clk(clk[1]),
.in(inRegister[1]),
.out(outRegister[1])
);

register r2(
.clk(clk[2]),
.in(inRegister[2]),
.out(outRegister[2])
);

register r3(
.clk(clk[3]),
.in(inRegister[3]),
.out(outRegister[3])
);

register r4(
.clk(clk[4]),
.in(inRegister[4]),
.out(outRegister[4])
);

register r5(
.clk(clk[5]),
.in(inRegister[5]),
.out(outRegister[5])
);

register r6(
.clk(clk[6]),
.in(inRegister[6]),
.out(outRegister[6])
);

register r7(
.clk(clk[7]),
.in(inRegister[7]),
.out(outRegister[7])
);



C c1(
.N1(outRegister[0]),
.N2(outRegister[1]),
.N3(outRegister[2]),
.N4(outRegister[3]),
.N5(outRegister[4]),
.N6(outRegister[5]),
.N7(outRegister[6]),
.N8(outRegister[7]),
.S1(S[0]),
.S2(S[1]),
.S3(S[2]),
.S4(S[3]),
.S5(S[4]),
.S6(S[5]),
.S7(S[6]),
.S8(S[7])
);

counter count(
	.sw(KEY[3]),
	.cin(Cin)
);

counter count2(
	.sw(KEY[1]),
	.cin(Cout)
);

demux DM1(
	.Data_in(SW[7:0]),
	.sel(Cin),
	.Data_out_0(inRegister[0]),
	.Data_out_1(inRegister[1]),
	.Data_out_2(inRegister[2]),
	.Data_out_3(inRegister[3]),
	.Data_out_4(inRegister[4]),
	.Data_out_5(inRegister[5]),
	.Data_out_6(inRegister[6]),
	.Data_out_7(inRegister[7])
);

demux_1 DM2(
	.Data_in(KEY[2]),
	.sel(Cin),
	.Data_out_0(clk[0]),
	.Data_out_1(clk[1]),
	.Data_out_2(clk[2]),
	.Data_out_3(clk[3]),
	.Data_out_4(clk[4]),
	.Data_out_5(clk[5]),
	.Data_out_6(clk[6]),
	.Data_out_7(clk[7])
);

mux MS(
	.N1(S[0]),
	.N2(S[1]),
	.N3(S[2]),
	.N4(S[3]),
	.N5(S[4]),
	.N6(S[5]),
	.N7(S[6]),
	.N8(S[7]),
	.sel(Cout),
	.S(resMS[7:0])
);

assign LEDR[0] = resMS[0];
assign LEDR[1] = resMS[1];
assign LEDR[2] = resMS[2];
assign LEDR[3] = resMS[3];
assign LEDR[4] = resMS[4];
assign LEDR[5] = resMS[5];
assign LEDR[6] = resMS[6];
assign LEDR[7] = resMS[7];

conversor conv(
	.N(resMS[7:0]),
	.S(res[9:0]),
	.S1(seg1[6:0]),
	.S2(seg2[6:0]),
	.S3(seg3[6:0])
);

assign HEX0 = seg1;
assign HEX1 = seg2;
assign HEX2 = seg3;

endmodule
